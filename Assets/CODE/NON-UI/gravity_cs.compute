#pragma kernel CSMain
#pragma kernel WipeGrid0
#pragma kernel WipeGrid1
#pragma kernel WipeGrid2
#pragma kernel WipeGrid3
#pragma kernel WipeGrid4
#pragma kernel WipeGrid5
#pragma kernel UpdateGrid0
#pragma kernel UpdateGrid1
#pragma kernel UpdateGrid2
#pragma kernel UpdateGrid3
#pragma kernel UpdateGrid4
#pragma kernel UpdateGrid5
#pragma kernel AddorRemoveDots
#pragma kernel CopyBuffer
#pragma kernel CalcTrajectory

struct dotData
{
    float3 color;
    float2 position;
    float2 velocity;
    float mass;
};

struct changeDotsStr
{
    uint changeID;
    float radius;
    float2 centerPos;
    float changeDataMass;
    float2 changeDataVel;
    float3 changeDataCol;
    /*

    changeID:
    0: Add
    1: Remove
    2: Change color
    3: Change mass
    
    69: Nothing
    */
};


struct Grid_str
{
    float2 position; // strating from the bottom left corner of the grid
    int2 MassTPossition;
    int mass;
    int jailerID;
    // jailerID is only used in GRID0 since there can be only one dot
    // in a cell. jailerID refereses this dot (or jailer) via his ID.
    // 
    
    /*
    Grid Sizes (6):
    0: 0.5x0.5
    1: 1x1     (x2)
    2: 2x2     (x2)
    3: 4x4     (x2)
    4: 8x8     (x2)
    5: 16x16   (x2)
    */

};

struct miscellaneousData
{
    int dotCount;
    int freeSpace;
};

struct trajectoryPath
{
    float2 position;
};


// constants or variables for physics
float G; 
float fixedDeltaTime;
static const float PI = 3.14159265358979323846;
static const int ThreadSize = 32;
static const int FloatIntScaler = 1000000; // 10^6

//MODES
int COLLISION = 0;

//CSMAIN
int DispatchOffset;

//AddorRemoveDot
int newdotamount;

//COPYKERNEL
int CopyID;

//trajectory kernel
int Distance;
float Resolution;
float2 CenterBallPoss;
groupshared float2 calcForceTraj[ThreadSize];


//Grid kernel
bool IsThisFristFrame = true;
float4 GridTargetPosition;
float4 GridSideLenght;
float4 GridCellLenght[6];
float4 GridTotalCellCount[6];
float4 GridSideCellCount[6];
float ActivationDistace[6] = {0, 8, 16, 32, 64, 128};

//Grid update kernel
groupshared float2 cellcenterofmass = 0;
groupshared float cellmass[32];
groupshared int cellcount[32];
groupshared float mpx[32]; // Mass * Position X
groupshared float mpy[32]; // Mass * Position Y



RWStructuredBuffer<dotData> inputData;     // Copy ID: 0   -in copy1
RWStructuredBuffer<dotData> inputData_TMP; // Copy ID: 1   -in copy1

RWStructuredBuffer<Grid_str> Grid0; // 0.5
RWStructuredBuffer<Grid_str> Grid1; // 1
RWStructuredBuffer<Grid_str> Grid2; // 2
RWStructuredBuffer<Grid_str> Grid3; // 4
RWStructuredBuffer<Grid_str> Grid4; // 8
RWStructuredBuffer<Grid_str> Grid5; // 16

RWStructuredBuffer<changeDotsStr> changeDots;
RWStructuredBuffer<miscellaneousData> miscData;
RWStructuredBuffer<trajectoryPath> trajPath;


groupshared float2 calcForce[ThreadSize];




[numthreads(1024, 1, 1)]
void WipeGrid0(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GridTotalCellCount[0].x) { return; }
    
    Grid0[id.x].mass = 0;
    Grid0[id.x].MassTPossition = 0;
    Grid0[id.x].position = float2(GridTargetPosition.x, GridTargetPosition.y);
    Grid0[id.x].jailerID = -1;
}

[numthreads(1024, 1, 1)]
void WipeGrid1(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GridTotalCellCount[1].x) { return; }
    
    Grid1[id.x].mass = 0;
    Grid1[id.x].MassTPossition = 0;
    Grid1[id.x].position = float2(GridTargetPosition.x, GridTargetPosition.y);
    Grid1[id.x].jailerID = -1;
}

[numthreads(1024, 1, 1)]
void WipeGrid2(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GridTotalCellCount[2].x) { return; }
    
    Grid2[id.x].mass = 0;
    Grid2[id.x].MassTPossition = 0;
    Grid2[id.x].position = float2(GridTargetPosition.x, GridTargetPosition.y);
    Grid2[id.x].jailerID = -1;
}

[numthreads(1024, 1, 1)]
void WipeGrid3(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GridTotalCellCount[3].x) { return; }
    
    Grid3[id.x].mass = 0;
    Grid3[id.x].MassTPossition = 0;
    Grid3[id.x].position = float2(GridTargetPosition.x, GridTargetPosition.y);
    Grid3[id.x].jailerID = -1;
}

[numthreads(1024, 1, 1)]
void WipeGrid4(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GridTotalCellCount[4].x) { return; }
    
    Grid4[id.x].mass = 0;
    Grid4[id.x].MassTPossition = 0;
    Grid4[id.x].position = float2(GridTargetPosition.x, GridTargetPosition.y);
    Grid4[id.x].jailerID = -1;
}

[numthreads(1024, 1, 1)]
void WipeGrid5(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GridTotalCellCount[5].x) { return; }
    
    Grid5[id.x].mass = 0;
    Grid5[id.x].MassTPossition = 0;
    Grid5[id.x].position = float2(GridTargetPosition.x, GridTargetPosition.y);
    Grid5[id.x].jailerID = -1;
}




[numthreads(1024, 1, 1)]
void UpdateGrid0(uint3 id : SV_DispatchThreadID){
    
    if (id.x >= miscData[0].dotCount)
        return;
    
    float currMass = inputData[id.x].mass;
    float2 currPoss = inputData[id.x].position;
    
    if ((currMass == 0) || !(currPoss.x >= GridTargetPosition.x && currPoss.y >= GridTargetPosition.y && currPoss.x < GridTargetPosition.x + GridSideLenght.x && currPoss.y < GridTargetPosition.y + GridSideLenght.x))
        return;
    
    uint cellindex = floor(currPoss.y/GridCellLenght[0].x) * GridSideCellCount[0].x + floor(currPoss.x/GridCellLenght[0].x);
    
    
    //since there can be only one dot in a cell, we can simplify the processe and not use atomics.
    Grid0[cellindex].mass             = int(floor(currMass * FloatIntScaler))); // floor is just there as a failsafe
    Grid0[cellindex].MassTPossition.x = int(floor(currMass * currPoss.x * FloatIntScaler))); 
    Grid0[cellindex].MassTPossition.y = int(floor(currMass * currPoss.y * FloatIntScaler))); 
    Grid0[cellindex].jailerID = id.x
}

[numthreads(1024, 1, 1)]
void UpdateGrid1(uint3 id : SV_DispatchThreadID){
    
    if (id.x >= miscData[0].dotCount)
        return;
    
    float currMass = inputData[id.x].mass;
    float2 currPoss = inputData[id.x].position;
    
    if ((currMass == 0) || !(currPoss.x >= GridTargetPosition.x && currPoss.y >= GridTargetPosition.y && currPoss.x < GridTargetPosition.x + GridSideLenght.x && currPoss.y < GridTargetPosition.y + GridSideLenght.x))
        return;
    

    //uint cellindex = (floor(currPoss.y/GridCellLenght[1]) * (1024.0/GridCellLenght[1])) + floor(currPoss.x/GridCellLenght[1]);

    uint cellindex = floor(currPoss.y/GridCellLenght[1].x) * GridSideCellCount[1].x + floor(currPoss.x/GridCellLenght[1].x);
    
    InterlockedAdd(Grid1[cellindex].mass,             int(floor(currMass * FloatIntScaler))); // floor is just there as a failsafe
    InterlockedAdd(Grid1[cellindex].MassTPossition.x, int(floor(currMass * currPoss.x * FloatIntScaler))); 
    InterlockedAdd(Grid1[cellindex].MassTPossition.y, int(floor(currMass * currPoss.y * FloatIntScaler))); 
}

[numthreads(1024, 1, 1)]
void UpdateGrid2(uint3 id : SV_DispatchThreadID){
    
    if (id.x >= miscData[0].dotCount)
        return;
    
    float currMass = inputData[id.x].mass;
    float2 currPoss = inputData[id.x].position;
    
    if ((currMass == 0) || !(currPoss.x >= GridTargetPosition.x && currPoss.y >= GridTargetPosition.y && currPoss.x < GridTargetPosition.x + GridSideLenght.x && currPoss.y < GridTargetPosition.y + GridSideLenght.x))
        return;
    
    uint cellindex = floor(currPoss.y/GridCellLenght[2].x) * GridSideCellCount[2].x + floor(currPoss.x/GridCellLenght[2].x);
    
    InterlockedAdd(Grid2[cellindex].mass,             int(floor(currMass * FloatIntScaler))); // floor is just there as a failsafe
    InterlockedAdd(Grid2[cellindex].MassTPossition.x, int(floor(currMass * currPoss.x * FloatIntScaler)));
    InterlockedAdd(Grid2[cellindex].MassTPossition.y, int(floor(currMass * currPoss.y * FloatIntScaler))); 
}

[numthreads(1024, 1, 1)]
void UpdateGrid3(uint3 id : SV_DispatchThreadID){
    
    if (id.x >= miscData[0].dotCount)
        return;
    
    float currMass = inputData[id.x].mass;
    float2 currPoss = inputData[id.x].position;
    
    if ((currMass == 0) || !(currPoss.x >= GridTargetPosition.x && currPoss.y >= GridTargetPosition.y && currPoss.x < GridTargetPosition.x + GridSideLenght.x && currPoss.y < GridTargetPosition.y + GridSideLenght.x))
        return;
    
    uint cellindex = floor(currPoss.y/GridCellLenght[3].x) * GridSideCellCount[3].x + floor(currPoss.x/GridCellLenght[3].x);
    
    InterlockedAdd(Grid3[cellindex].mass,             int(floor(currMass * FloatIntScaler))); // floor is just there as a failsafe
    InterlockedAdd(Grid3[cellindex].MassTPossition.x, int(floor(currMass * currPoss.x * FloatIntScaler))); 
    InterlockedAdd(Grid3[cellindex].MassTPossition.y, int(floor(currMass * currPoss.y * FloatIntScaler))); 
}

[numthreads(1024, 1, 1)]
void UpdateGrid4(uint3 id : SV_DispatchThreadID){
    
    if (id.x >= miscData[0].dotCount)
        return;
    
    float currMass = inputData[id.x].mass;
    float2 currPoss = inputData[id.x].position;
    
    if ((currMass == 0) || !(currPoss.x >= GridTargetPosition.x && currPoss.y >= GridTargetPosition.y && currPoss.x < GridTargetPosition.x + GridSideLenght.x && currPoss.y < GridTargetPosition.y + GridSideLenght.x))
        return;
    
    uint cellindex = floor(currPoss.y/GridCellLenght[4].x) * GridSideCellCount[4].x + floor(currPoss.x/GridCellLenght[4].x);
    
    InterlockedAdd(Grid4[cellindex].mass,             int(floor(currMass * FloatIntScaler))); // floor is just there as a failsafe
    InterlockedAdd(Grid4[cellindex].MassTPossition.x, int(floor(currMass * currPoss.x * FloatIntScaler))); 
    InterlockedAdd(Grid4[cellindex].MassTPossition.y, int(floor(currMass * currPoss.y * FloatIntScaler))); 
}

[numthreads(1024, 1, 1)]
void UpdateGrid5(uint3 id : SV_DispatchThreadID){
    
    if (id.x >= miscData[0].dotCount)
        return;
    
    float currMass = inputData[id.x].mass;
    float2 currPoss = inputData[id.x].position;
    
    if ((currMass == 0) || !(currPoss.x >= GridTargetPosition.x && currPoss.y >= GridTargetPosition.y && currPoss.x < GridTargetPosition.x + GridSideLenght.x && currPoss.y < GridTargetPosition.y + GridSideLenght.x))
        return;
    
    uint cellindex = floor(currPoss.y/GridCellLenght[5].x) * GridSideCellCount[5].x + floor(currPoss.x/GridCellLenght[5].x);
    
    InterlockedAdd(Grid5[cellindex].mass,             int(floor(currMass * FloatIntScaler))); // floor is just there as a failsafe
    InterlockedAdd(Grid5[cellindex].MassTPossition.x, int(floor(currMass * currPoss.x * FloatIntScaler))); 
    InterlockedAdd(Grid5[cellindex].MassTPossition.y, int(floor(currMass * currPoss.y * FloatIntScaler))); 
}




[numthreads(4, 4, 2)]
void CSMain(int GroupIndex : SV_GroupIndex, uint3 GroupID : SV_GroupID){

    uint DispatchGroupIndex = (GroupID.x + GroupID.y * ThreadSize + GroupID.z * ThreadSize * ThreadSize) + DispatchOffset; //index of the current group
    
    int currMass = inputData[DispatchGroupIndex].mass;
    float2 currPoss = inputData[DispatchGroupIndex].position;
    float2 currVelo = inputData[DispatchGroupIndex].velocity;
    float3 currColo = inputData[DispatchGroupIndex].color;
    
    calcForce[GroupIndex] = 0;
    
    uint dotCount = uint(miscData[0].dotCount);
    
    int B = 0;
    int E = 0;
    
    int Start_cord = 0;
    int End_cord = 0;
    
    
    // calculate everybodies forces
    if (DispatchGroupIndex <= dotCount && currMass != 0)
    {
        B = floor((dotCount - 1.0) / ThreadSize);
        E = (dotCount - 1.0) % ThreadSize;
    
        Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
        End_cord   = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
        
        
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float Current_Target_Mass = inputData[Current_Target_index].mass;
            // checks if object is not deleted
            if (Current_Target_Mass == 0) { continue; } 
            

            float2 Current_Target_Poss = inputData[Current_Target_index].position;
            // checks if its not the same obj and if its not too close
            if ((currPoss.x == Current_Target_Poss.x && currPoss.y == Current_Target_Poss.y) || distance(currPoss, Current_Target_Poss) <= 1) { continue; } 


            
            float F = G * ((currMass * Current_Target_Mass) / pow(distance(currPoss, Current_Target_Poss), 2.0)); // (pow(currPoss.x - Current_Target_Poss.x, 2) + pow(currPoss.y - Current_Target_Poss.y, 2))); 
            float alpha = atan2((currPoss.y - Current_Target_Poss.y), (currPoss.x - Current_Target_Poss.x));
            
            calcForce[GroupIndex] += float2(cos(alpha) * F, sin(alpha) * F);
        }
    }
    
    GroupMemoryBarrierWithGroupSync();

    // main thread (which is 0) sums all of the other threads results into one singular result
    if (GroupIndex == 0)
    {
        
        float2 summForce = float2(0,0);
        for (int i = 0; i < ThreadSize; i++)
        {
            summForce += calcForce[i];
        }
        
        //Coneverts calculated force to bodies velocity
        
        //F=ma -> a=F/m

        //dont get why splitting vel calculations into 2 helps, but without it it causes extra unwanted vel
        currVelo += (summForce / currMass) * fixedDeltaTime * 0.5;
        
        currPoss -= currVelo * fixedDeltaTime;

        currVelo += (summForce / currMass) * fixedDeltaTime * 0.5;
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    /*
        COLLISION DETECTION
    */
    
    if (COLLISION == 1)
    {
        
        //narrow phase
        
        uint cellID = floor(currPoss.y/GridCellLenght[0].x) * GridSideCellCount[0].x + floor(currPoss.x/GridCellLenght[0].x);
        
        //check left
        if (Grid0[cellID-1].jailerID != -1)
        {
            uint targetID = Grid0[cellID-1].jailerID;
            
            //colision detected
            if (distance(currPoss, inputData[targetID].position) <= 1)
            {
                float2 jailerPoss = inputData[targetID].position;
                
                float2 normal = float2(0,0);
            }
        }
        //check up-left
        else if (Grid0[cellID+GridSideCellCount[0].x-1].jailerID != -1)
        {
            
        }
        //check up
        else if (Grid0[cellID+GridSideCellCount[0].x].jailerID != -1)
        {
            
        }
        //check up-right
        else if (Grid0[cellID+GridSideCellCount[0].x+1].jailerID != -1)
        {
            
        }
        //check right
        else if (Grid0[cellID+1].jailerID != -1)
        {
            
        }
        //check down-right
        else if (Grid0[cellID-GridSideCellCount[0].x+1].jailerID != -1)
        {
            
        }
        //check down
        else if (Grid0[cellID-GridSideCellCount[0].x].jailerID != -1)
        {
            
        }
        //check down-left
        else if (Grid0[cellID-GridSideCellCount[0].x-1].jailerID != -1)
        {
            
        }
        
        
    }
    
    

    
    GroupMemoryBarrierWithGroupSync();
    // output
    if (GroupIndex == 0)
    {
        inputData[DispatchGroupIndex].color = currColo;
        inputData[DispatchGroupIndex].position = currPoss;
        inputData[DispatchGroupIndex].velocity = currVelo;
        inputData[DispatchGroupIndex].mass = currMass;
    }
}







[numthreads(4, 4, 2)]
void AddorRemoveDots(int GroupIndex : SV_GroupIndex){
    if (changeDots[0].changeID == 69) { return; }
    
    

    int dotCount = miscData[0].dotCount;
    int freeSpace = miscData[0].freeSpace;
    int currFreeSpace = 0;

    int Start_cord = 0;
    int End_cord = 0;
    
    
    int B = floor((dotCount - 1.0) / ThreadSize);
    int E = (dotCount - 1.0) % ThreadSize;
    
    
    Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
    End_cord = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
    
    // add
    if (changeDots[0].changeID == 0 && GroupIndex == 0) 
    {   
        int iteration = 0;
        float dist = 1;
        
        for (int Current_Target_index = 0; Current_Target_index <= dotCount; Current_Target_index++)
        {
            if (inputData[Current_Target_index].mass == 0)
            {
                
                float current_theta = 0.0; //in radians
                float beta = 0.0;
                float n = 0;
                dist = 1;


                iteration++;
                InterlockedAdd(miscData[0].freeSpace, -1);
                
                inputData[Current_Target_index].mass = changeDots[0].changeDataMass;
                inputData[Current_Target_index].color = changeDots[0].changeDataCol;
                inputData[Current_Target_index].velocity = changeDots[0].changeDataVel;
                
                
                for (int id = 0; id < iteration; id++)
                {
                    beta = 2.0 * atan(0.5/dist);
                    n = (2.0 * PI)/beta;
                    
                    if ((id + floor(n)) < iteration){
                        id += floor(n);
                        dist++;
                    }
                    else if(floor(changeDots[0].radius) <= dist){
                        break;
                    }
                    else{
                        float alpha = (2.0*PI)/floor(n);
                        current_theta = abs(iteration-id)*alpha;
                        break;         
                    }
                    
                }

                inputData[Current_Target_index].position = float2(dist * cos(current_theta), dist * sin(current_theta)) + changeDots[0].centerPos;

                float2 newpos = inputData[Current_Target_index].position - changeDots[0].centerPos;

                float2x2 Forcematrix = {
                    cos(atan2(newpos.x, newpos.y)), -sin(atan2(newpos.x, newpos.y)),
                    sin(atan2(newpos.x, newpos.y)),  cos(atan2(newpos.x, newpos.y))
                };

                //inputData[Current_Target_index].velocity -= mul(float2(1, 1) * (G*G / dist), Forcematrix);// mul(float2(1, 1) * sqrt((G * changeDots[0].changeDataMass * newdotamount) / newpos), Forcematrix);
                

                

                
                if (floor(changeDots[0].radius) <= dist){
                    break;
                }
            }

        }
    }
    // remove
    else if (changeDots[0].changeID == 1) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius && inputData[Current_Target_index].mass != 0)
            {
                inputData[Current_Target_index].mass = 0;
                inputData[Current_Target_index].position = float2(0,0);
                inputData[Current_Target_index].velocity = float2(0,0);
                currFreeSpace++;
            }
        }
    }
    // change color
    else if (changeDots[0].changeID == 2) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius)
            {
                inputData[Current_Target_index].color = changeDots[0].changeDataCol;
            }
        }
    }
    // change mass
    else if (changeDots[0].changeID == 3) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius)
            {
                inputData[Current_Target_index].mass = changeDots[0].changeDataMass;
            }
        }
    }

    
    InterlockedAdd(miscData[0].freeSpace, currFreeSpace);
}




//from inputdata, Grid0 to Grid2_TMP
[numthreads(64, 1, 1)]
void CopyBuffer(uint GroupIndex : SV_GroupIndex){

    uint numStructs = 0;
    uint stride = 0;

    switch (CopyID)
    {
       
       
        case 0:
            inputData.GetDimensions(numStructs, stride);
            for (uint pos = GroupIndex; pos < numStructs; pos += 64)
            {
                inputData[pos] = inputData_TMP[pos];
            }
            break;
        case 1:
            inputData_TMP.GetDimensions(numStructs, stride);
            for (uint pos1 = GroupIndex; pos1 < numStructs; pos1 += 64)
            {
                inputData_TMP[pos1] = inputData[pos1];
            }
            break;
    }
}


[numthreads(4, 4, 2)]
void CalcTrajectory(int GroupIndex : SV_GroupIndex)
{
    
    float2 currPoss = CenterBallPoss;
    float2 currVelo = changeDots[0].changeDataVel;
    uint dotCount = uint(miscData[0].dotCount);
    
    if (GroupIndex == 0) {trajPath[0].position = currPoss;}
    
    int B = floor((dotCount - 1.0) / ThreadSize);
    int E = (dotCount - 1.0) % ThreadSize;
    int Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
    int End_cord = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
    int index = 0;
    
    // calculates trajectories path
    for (int i = 1; i < Distance; i++)
    {
        calcForceTraj[GroupIndex] = 0;
    
        
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float Current_Target_Mass = inputData[Current_Target_index].mass;
            // checks if object is not deleted
            if (Current_Target_Mass == 0) { continue; } 
            
            float2 Current_Target_Poss = inputData[Current_Target_index].position;
            
            // checks if its not too close
            if (distance(currPoss, Current_Target_Poss) <= 1) { continue; } 

            
            float F = G * ((Current_Target_Mass * changeDots[0].changeDataMass) / pow(distance(currPoss, Current_Target_Poss), 2.0)); // (pow(currPoss.x - Current_Target_Poss.x, 2) + pow(currPoss.y - Current_Target_Poss.y, 2))); 
            float alpha = atan2((currPoss.y - Current_Target_Poss.y), (currPoss.x - Current_Target_Poss.x));
            
            calcForceTraj[GroupIndex] += float2(cos(alpha) * F, sin(alpha) * F);
        }
    
        GroupMemoryBarrierWithGroupSync();

        // main thread (which is 0) sums all of the other threads results into one singular result
        if (GroupIndex == 0)
        {
        
            float2 summForce = float2(0,0);
            for (int i = 0; i < ThreadSize; i++)
            {
                summForce += calcForceTraj[i];
            }
        
            //Coneverts calculated force to bodies velocity
        
            //F=ma -> a=F/m

            //dont get why splitting vel calculations into 2 helps, but without it it causes extra unwanted vel
            currVelo += (summForce / changeDots[0].changeDataMass) * fixedDeltaTime * 0.5 * Resolution; //(1/Resolution)
        
            currPoss -= currVelo * fixedDeltaTime * Resolution;

            currVelo += (summForce / changeDots[0].changeDataMass) * fixedDeltaTime * 0.5 * Resolution;
            
            trajPath[index].position = currPoss;
            index++;
        }
    }
    trajPath[index].position = currPoss;
}