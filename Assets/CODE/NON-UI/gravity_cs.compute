#pragma kernel CSMain
#pragma kernel AddorRemoveDots
#pragma kernel CopyBuffer
#pragma kernel CalcTrajectory

struct dotData
{
    float3 color;
    float2 position;
    float2 velocity;
    float mass;
};

struct changeDotsStr
{
    uint changeID;
    float radius;
    float2 centerPos;
    float changeDataMass;
    float2 changeDataVel;
    float3 changeDataCol;
    /*

    changeID:
    0: Add
    1: Remove
    2: Change color
    3: Change mass
    
    69: Nothing
    */
};

struct miscellaneousData
{
    int dotCount;
    int freeSpace;
};

struct trajectoryPath
{
    float2 position;
};


// constants or variables for physics
float G; 
float4 fixedDeltaTime;
static const float PI = 3.14159265358979323846;
static const int ThreadSize = 32;
static const int FloatIntScaler = 1000000; // 10^6

//MODES
float4 COLLISION;

//CSMAIN
int DispatchOffset;

//AddorRemoveDot
int newdotamount;

//COPYKERNEL
int CopyID;

//trajectory kernel
int Distance;
float Resolution;
float2 CenterBallPoss;
groupshared float2 calcForceTraj[ThreadSize];



RWStructuredBuffer<dotData> inputData;     // Copy ID: 0   -in copy1
RWStructuredBuffer<dotData> inputData_TMP; // Copy ID: 1   -in copy1


RWStructuredBuffer<changeDotsStr> changeDots;
RWStructuredBuffer<miscellaneousData> miscData;
RWStructuredBuffer<trajectoryPath> trajPath;


groupshared float2 calcForce[ThreadSize];



float pithagoras(float2 vec)
{
    return sqrt(vec.x*vec.x + vec.y*vec.y);
}


[numthreads(4, 4, 2)]
void CSMain(int GroupIndex : SV_GroupIndex, uint3 GroupID : SV_GroupID){

    uint DispatchGroupIndex = (GroupID.x + GroupID.y * ThreadSize + GroupID.z * ThreadSize * ThreadSize) + DispatchOffset; //index of the current group
    
    float c = -0.9;
    int currMass = inputData[DispatchGroupIndex].mass;
    float2 currPoss = inputData[DispatchGroupIndex].position;
    float2 currVelo = inputData[DispatchGroupIndex].velocity;
    float3 currColo = inputData[DispatchGroupIndex].color;
    
    calcForce[GroupIndex] = 0;
    
    uint dotCount = uint(miscData[0].dotCount);
    
    int B = 0;
    int E = 0;
    
    int Start_cord = 0;
    int End_cord = 0;
    
    //currColo = float3(1,1,1);
    // calculate everybodies forces
    if (DispatchGroupIndex <= dotCount && currMass != 0)
    {
        B = floor((dotCount - 1.0) / ThreadSize);
        E = (dotCount - 1.0) % ThreadSize;
    
        Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
        End_cord   = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
        
        
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float Current_Target_Mass = inputData[Current_Target_index].mass;
            // checks if object is not deleted
            if (Current_Target_Mass == 0) { continue; } 
            

            float2 Current_Target_Poss = inputData[Current_Target_index].position;
            // checks if its not the same obj
            if ((currPoss.x == Current_Target_Poss.x && currPoss.y == Current_Target_Poss.y)) { continue; }
            
            float OBJ_dist = distance(currPoss, Current_Target_Poss);
            if (OBJ_dist <= 1)
            {
                continue;
                currColo = float3(1,0,0);
                    
                float2 jailerPoss = inputData[Current_Target_index].position;
                float2 jailerVel = inputData[Current_Target_index].velocity;
                float jailerMass = inputData[Current_Target_index].mass;
                
                //adjust the possition
                if (OBJ_dist < 1)
                {
                    float2 center = float2(0.5*abs(jailerPoss.x - currPoss.x) + min(jailerPoss.x, currPoss.x), 0.5*abs(jailerPoss.y - currPoss.y) + min(jailerPoss.y, currPoss.y));
                    
                    float alpha_c = atan2(center.y - currPoss.y, center.x - currPoss.x);
                    float alpha_cj = atan2(center.y - jailerPoss.y, center.x - jailerPoss.x);
                    
                    currPoss = float2(center.x + 0.5*cos(alpha_c), center.y + 0.5*sin(alpha_c)); //normaly this should be also be * by r, but in this case r is 1
                    jailerPoss = float2(center.x + 0.5*cos(alpha_cj), center.y + 0.5*sin(alpha_cj));
                    
                    OBJ_dist = 1;
                }
                
                float2 Normal = float2( 
                    (jailerPoss.x - currPoss.x)/OBJ_dist, 
                    (jailerPoss.y - currPoss.y)/OBJ_dist
                );
                
                currVelo = currVelo - ((2.0 * jailerMass)/(currMass+jailerMass)) * ((dot(currVelo-jailerVel, currPoss-jailerPoss)) / (pow( pithagoras(currPoss - jailerPoss), 2))) * (currPoss - jailerPoss); //+ (0.1 * Normal * (1 - pow(distance(currPoss, jailerPoss), -1)));
                
                
                
                float vn = dot(currVelo, Normal);
                
                /*if (vn < 0)
                    currVelo -= vn * Normal;*/
                /*float j = ((currMass*jailerMass) / (currMass + jailerMass)) * (1 + c) * (jailerVel - currVelo) * Normal;
                currVelo = (j/currMass)*Normal;*/
                
                
            }

            
            float F = G * ((currMass * Current_Target_Mass) / pow(OBJ_dist, 2.0)); // (pow(currPoss.x - Current_Target_Poss.x, 2) + pow(currPoss.y - Current_Target_Poss.y, 2))); 
            float alpha = atan2((currPoss.y - Current_Target_Poss.y), (currPoss.x - Current_Target_Poss.x));
            
            calcForce[GroupIndex] += float2(cos(alpha) * F, sin(alpha) * F);
        }
    }
    
    GroupMemoryBarrierWithGroupSync();

    // main thread (which is 0) sums all of the other threads results into one singular result
    if (GroupIndex == 0)
    {
        
        float2 summForce = float2(0,0);
        for (int i = 0; i < ThreadSize; i++)
        {
            summForce += calcForce[i];
        }
        
        //Coneverts calculated force to bodies velocity
        
        //F=ma -> a=F/m

        //dont get why splitting vel calculations into 2 helps, but without it it causes extra unwanted vel
        currVelo += (summForce / currMass) * fixedDeltaTime.x * 0.5;
        
        currPoss -= currVelo * fixedDeltaTime.x;

        currVelo += (summForce / currMass) * fixedDeltaTime.x * 0.5;

    }
    
    GroupMemoryBarrierWithGroupSync();

    /*
        COLLISION DETECTION
    */
    
    if (COLLISION.x == 1 && GroupIndex == 0)
    {
        

        /*//colision detectecion
        if (distance(currPoss, inputData[6969].position) <= 1 && targetID != DispatchGroupIndex)
        {
            currColo = float3(1,0,0);
                    
            /*float2 jailerPoss = inputData[targetID].position;
            float2 jailerVel = inputData[targetID].velocity;
            float jailerMass = inputData[targetID].mass;

            float dist = distance(jailerPoss, currPoss);
                    
            float2 Normal = float2(
                (jailerPoss.x - currPoss.x)/dist,
                (jailerPoss.y - currPoss.y)/dist
            );
                    
            float2 Tangent = float2(-Normal.y, Normal.x);
                    
            float DpTan = currVelo.x * Tangent.x + currVelo.y * Tangent.y;
                    
            float DpNormal1 = currVelo.x * Normal.x + currVelo.y * Normal.y;
            float DpNormal2 = jailerVel.x * Normal.x + jailerVel.y * Normal.y;
                    
            float momentum = (DpNormal1 * (currMass - jailerMass) + 2.0 * jailerMass * DpNormal2) / (currMass + jailerMass);
                    
            currVelo.x -= Tangent.x * DpTan + Normal.x * momentum;
            currVelo.y -= Tangent.y * DpTan + Normal.y * momentum;*/
            /*currVelo.x = -currVelo.x;
            currVelo.y = -currVelo.y;
            
        }*/
        
    }
    
    

    
    GroupMemoryBarrierWithGroupSync();
    // output
    if (GroupIndex == 0)
    {
        inputData[DispatchGroupIndex].color = currColo;
        inputData[DispatchGroupIndex].position = currPoss;
        inputData[DispatchGroupIndex].velocity = currVelo;
        inputData[DispatchGroupIndex].mass = currMass;
    }
}







[numthreads(4, 4, 2)]
void AddorRemoveDots(int GroupIndex : SV_GroupIndex){
    if (changeDots[0].changeID == 69) { return; }
    
    

    int dotCount = miscData[0].dotCount;
    int freeSpace = miscData[0].freeSpace;
    int currFreeSpace = 0;

    int Start_cord = 0;
    int End_cord = 0;
    
    
    int B = floor((dotCount - 1.0) / ThreadSize);
    int E = (dotCount - 1.0) % ThreadSize;
    
    
    Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
    End_cord = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
    
    // add
    if (changeDots[0].changeID == 0 && GroupIndex == 0) 
    {   
        int iteration = 0;
        float dist = 1;
        
        for (int Current_Target_index = 0; Current_Target_index <= dotCount; Current_Target_index++)
        {
            if (inputData[Current_Target_index].mass == 0)
            {
                
                float current_theta = 0.0; //in radians
                float beta = 0.0;
                float n = 0;
                dist = 1;


                iteration++;
                InterlockedAdd(miscData[0].freeSpace, -1);
                
                inputData[Current_Target_index].mass = changeDots[0].changeDataMass;
                inputData[Current_Target_index].color = changeDots[0].changeDataCol;
                inputData[Current_Target_index].velocity = changeDots[0].changeDataVel;
                
                
                for (int id = 0; id < iteration; id++)
                {
                    beta = 2.0 * atan(0.5/dist);
                    n = (2.0 * PI)/beta;
                    
                    if ((id + floor(n)) < iteration){
                        id += floor(n);
                        dist++;
                    }
                    else if(floor(changeDots[0].radius) <= dist){
                        break;
                    }
                    else{
                        float alpha = (2.0*PI)/floor(n);
                        current_theta = abs(iteration-id)*alpha;
                        break;         
                    }
                    
                }

                inputData[Current_Target_index].position = float2(dist * cos(current_theta), dist * sin(current_theta)) + changeDots[0].centerPos;

                float2 newpos = inputData[Current_Target_index].position - changeDots[0].centerPos;

                float2x2 Forcematrix = {
                    cos(atan2(newpos.x, newpos.y)), -sin(atan2(newpos.x, newpos.y)),
                    sin(atan2(newpos.x, newpos.y)),  cos(atan2(newpos.x, newpos.y))
                };

                //inputData[Current_Target_index].velocity -= mul(float2(1, 1) * (G*G / dist), Forcematrix);// mul(float2(1, 1) * sqrt((G * changeDots[0].changeDataMass * newdotamount) / newpos), Forcematrix);
                

                

                
                if (floor(changeDots[0].radius) <= dist){
                    break;
                }
            }

        }
    }
    // remove
    else if (changeDots[0].changeID == 1) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius && inputData[Current_Target_index].mass != 0)
            {
                inputData[Current_Target_index].mass = 0;
                inputData[Current_Target_index].position = float2(0,0);
                inputData[Current_Target_index].velocity = float2(0,0);
                currFreeSpace++;
            }
        }
    }
    // change color
    else if (changeDots[0].changeID == 2) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius)
            {
                inputData[Current_Target_index].color = changeDots[0].changeDataCol;
            }
        }
    }
    // change mass
    else if (changeDots[0].changeID == 3) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius)
            {
                inputData[Current_Target_index].mass = changeDots[0].changeDataMass;
            }
        }
    }

    
    InterlockedAdd(miscData[0].freeSpace, currFreeSpace);
}




//from inputdata
[numthreads(64, 1, 1)]
void CopyBuffer(uint GroupIndex : SV_GroupIndex){

    uint numStructs = 0;
    uint stride = 0;

    switch (CopyID)
    {
       
       
        case 0:
            inputData.GetDimensions(numStructs, stride);
            for (uint pos = GroupIndex; pos < numStructs; pos += 64)
            {
                inputData[pos] = inputData_TMP[pos];
            }
            break;
        case 1:
            inputData_TMP.GetDimensions(numStructs, stride);
            for (uint pos1 = GroupIndex; pos1 < numStructs; pos1 += 64)
            {
                inputData_TMP[pos1] = inputData[pos1];
            }
            break;
    }
}


[numthreads(4, 4, 2)]
void CalcTrajectory(int GroupIndex : SV_GroupIndex)
{
    
    float2 currPoss = CenterBallPoss;
    float2 currVelo = changeDots[0].changeDataVel;
    uint dotCount = uint(miscData[0].dotCount);
    
    if (GroupIndex == 0) {trajPath[0].position = currPoss;}
    
    int B = floor((dotCount - 1.0) / ThreadSize);
    int E = (dotCount - 1.0) % ThreadSize;
    int Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
    int End_cord = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
    int index = 0;
    
    // calculates trajectories path
    for (int i = 1; i < Distance; i++)
    {
        calcForceTraj[GroupIndex] = 0;
    
        
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float Current_Target_Mass = inputData[Current_Target_index].mass;
            // checks if object is not deleted
            if (Current_Target_Mass == 0) { continue; } 
            
            float2 Current_Target_Poss = inputData[Current_Target_index].position;
            
            // checks if its not too close
            if (distance(currPoss, Current_Target_Poss) <= 1) { continue; } 

            
            float F = G * ((Current_Target_Mass * changeDots[0].changeDataMass) / pow(distance(currPoss, Current_Target_Poss), 2.0)); // (pow(currPoss.x - Current_Target_Poss.x, 2) + pow(currPoss.y - Current_Target_Poss.y, 2))); 
            float alpha = atan2((currPoss.y - Current_Target_Poss.y), (currPoss.x - Current_Target_Poss.x));
            
            calcForceTraj[GroupIndex] += float2(cos(alpha) * F, sin(alpha) * F);
        }
    
        GroupMemoryBarrierWithGroupSync();

        // main thread (which is 0) sums all of the other threads results into one singular result
        if (GroupIndex == 0)
        {
        
            float2 summForce = float2(0,0);
            for (int i = 0; i < ThreadSize; i++)
            {
                summForce += calcForceTraj[i];
            }
        
            //Coneverts calculated force to bodies velocity
        
            //F=ma -> a=F/m

            //dont get why splitting vel calculations into 2 helps, but without it it causes extra unwanted vel
            currVelo += (summForce / changeDots[0].changeDataMass) * fixedDeltaTime.x * 0.5 * Resolution; //(1/Resolution)
        
            currPoss -= currVelo * fixedDeltaTime.x * Resolution;

            currVelo += (summForce / changeDots[0].changeDataMass) * fixedDeltaTime.x * 0.5 * Resolution;
            
            trajPath[index].position = currPoss;
            index++;
        }
    }
    trajPath[index].position = currPoss;
}