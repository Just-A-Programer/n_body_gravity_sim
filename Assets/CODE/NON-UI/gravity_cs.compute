#pragma kernel CSMain

#pragma kernel UpdateGrid
#pragma kernel AddorRemoveDots
#pragma kernel CopyBuffer
#pragma kernel CalcTrajectory

struct dotData
{
    float3 color;
    float2 position;
    float2 velocity;
    float mass;
};

struct changeDotsStr
{
    uint changeID;
    float radius;
    float2 centerPos;
    float changeDataMass;
    float2 changeDataVel;
    float3 changeDataCol;
    /*

    changeID:
    0: Add
    1: Remove
    2: Change color
    3: Change mass
    
    69: Nothing
    */
};

struct Grid_str
{
    int2 position; // strating from the bottom left corner of the grid
    float2 localCenterOfMass;
    float mass;

    /*
    Grid Sizes (6):
    0: 0.5x0.5
    1: 1x1     (x2)
    2: 2x2     (x2)
    3: 4x4     (x2)
    4: 8x8     (x2)
    5: 16x16   (x2)
    */

};

struct miscellaneousData
{
    int dotCount;
    int freeSpace;
};

struct trajectoryPath
{
    float2 position;
};

struct Debug
{
    float2 DebugMatrix_n0;
    float2 DebugMatrix_n1;
    float2 DebugMatrix_n2;
    float2 DebugMatrix_n3;
};



// constants or variables for physics
float G; 
float fixedDeltaTime;
static const float PI = 3.14159265358979323846;
static const int ThreadSize = 32;

//MODES
int DEBUGMODE = 0;
int COLLISION = 0;

//CSMAIN
int DispatchOffset;

//AddorRemoveDot
int newdotamount;

//COPYKERNEL
int CopyID;

//trajectory kernel
int Distance;
float Resolution;
float2 CenterBallPoss;
groupshared float2 calcForceTraj[ThreadSize];


//Grid distance for calculations
float GridSideLenght;
float ActivationDistace[6] = {0, 8, 16, 32, 64, 128};
float GridCellLenght[6];
float GridTotalCellCount[6];
float GridSideCellCount[6];


RWStructuredBuffer<dotData> inputData;     // Copy ID: 0   -in copy1
RWStructuredBuffer<dotData> inputData_TMP; // Copy ID: 1   -in copy1

RWStructuredBuffer<Grid_str> Grid0; // 0.5
RWStructuredBuffer<Grid_str> Grid1; // 1
RWStructuredBuffer<Grid_str> Grid2; // 2
RWStructuredBuffer<Grid_str> Grid3; // 4
RWStructuredBuffer<Grid_str> Grid4; // 8
RWStructuredBuffer<Grid_str> Grid5; // 16


RWStructuredBuffer<changeDotsStr> changeDots;
RWStructuredBuffer<miscellaneousData> miscData;
RWStructuredBuffer<trajectoryPath> trajPath;
RWStructuredBuffer<Debug> debugData;


groupshared float2 calcForce[ThreadSize];


[numthreads(4, 4, 2)]
void CSMain(int GroupIndex : SV_GroupIndex, uint3 GroupID : SV_GroupID){

    uint DispatchGroupIndex = (GroupID.x + GroupID.y * ThreadSize + GroupID.z * ThreadSize * ThreadSize) + DispatchOffset; //index of the current group
    
    int currMass = inputData[DispatchGroupIndex].mass;
    float2 currPoss = inputData[DispatchGroupIndex].position;
    float2 currVelo = inputData[DispatchGroupIndex].velocity;
    float3 currColo = inputData[DispatchGroupIndex].color;
    
    calcForce[GroupIndex] = 0;
    
    uint dotCount = uint(miscData[0].dotCount);
    
    int B = 0;
    int E = 0;
    
    int Start_cord = 0;
    int End_cord = 0;

    int limit = 20000;
    // calculate everybodies forces
    if (DispatchGroupIndex <= dotCount && currMass != 0)
    {
        B = floor((dotCount - 1.0) / ThreadSize);
        E = (dotCount - 1.0) % ThreadSize;
    
        Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
        End_cord   = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
        
        
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float Current_Target_Mass = inputData[Current_Target_index].mass;
            // checks if object is not deleted
            if (Current_Target_Mass == 0) { continue; } 
            

            float2 Current_Target_Poss = inputData[Current_Target_index].position;
            // checks if its not the same obj and if its not too close
            if ((currPoss.x == Current_Target_Poss.x && currPoss.y == Current_Target_Poss.y) || distance(currPoss, Current_Target_Poss) <= 1) { continue; } 


            
            float F = G * ((currMass * Current_Target_Mass) / pow(distance(currPoss, Current_Target_Poss), 2.0)); // (pow(currPoss.x - Current_Target_Poss.x, 2) + pow(currPoss.y - Current_Target_Poss.y, 2))); 
            float alpha = atan2((currPoss.y - Current_Target_Poss.y), (currPoss.x - Current_Target_Poss.x));
            
            calcForce[GroupIndex] += float2(cos(alpha) * F, sin(alpha) * F);
        }
    }
    
    GroupMemoryBarrierWithGroupSync();

    // main thread (which is 0) sums all of the other threads results into one singular result
    if (GroupIndex == 0)
    {
        
        float2 summForce = float2(0,0);
        for (int i = 0; i < ThreadSize; i++)
        {
            summForce += calcForce[i];
        }
        
        //Coneverts calculated force to bodies velocity
        
        //F=ma -> a=F/m

        //dont get why splitting vel calculations into 2 helps, but without it it causes extra unwanted vel
        currVelo += (summForce / currMass) * fixedDeltaTime * 0.5;
        
        currPoss -= currVelo * fixedDeltaTime;

        currVelo += (summForce / currMass) * fixedDeltaTime * 0.5;
    }
    
    GroupMemoryBarrierWithGroupSync();

    /*
        COLLISION DETECTION
    */
    
    if (COLLISION == 1)
    {
        
        
        
        
        
        
    }
    
    

    
    GroupMemoryBarrierWithGroupSync();
    // debug output
    if (GroupIndex == 0 && DEBUGMODE == 1)
    {
        debugData[DispatchGroupIndex].DebugMatrix_n2.x = 0;
        debugData[DispatchGroupIndex].DebugMatrix_n2.y = 0;
        debugData[DispatchGroupIndex].DebugMatrix_n3.x = 0;
        debugData[DispatchGroupIndex].DebugMatrix_n3.y = 0;
    }
    // output
    if (GroupIndex == 0)
    {
        inputData[DispatchGroupIndex].color = currColo;
        inputData[DispatchGroupIndex].position = currPoss;
        inputData[DispatchGroupIndex].velocity = currVelo;
        inputData[DispatchGroupIndex].mass = currMass;
    }
}





[numthreads(4, 4, 2)]
void UpdateGrid(int GroupIndex : SV_GroupIndex, uint3 GroupID : SV_GroupID){
    
    
    int Level = GroupID.x;
    uint GridCount = 0;
    uint dotCount = uint(miscData[0].dotCount);
    
    
    //Add new Grid's
    int B = floor((dotCount - 1.0) / ThreadSize);;
    int E = (dotCount - 1.0) % ThreadSize;
    int Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
    int End_cord   = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
        
    if (Level == 0)
    {
        for (int Current_Dot_index = Start_cord; Current_Dot_index <= End_cord; Current_Dot_index++)
        {
            float2 DotPoss = inputData[Current_Dot_index].position;
            float2 PossibleGridPoss = DotPoss - DotPoss % GridCellLenght[Level];
            
            bool isitaLonelyDot = true;
            //a possible Dot (Lonely Dot) without Grid. Now it needs to be found if there is an Grid0 that has the Dot
            for (int i = 0; i < dotCount; i++) { if (Grid0[i].position.x == PossibleGridPoss.x && Grid0[i].position.y == PossibleGridPoss.y) { isitaLonelyDot = false; break;} }
            
            //it has
            if (!isitaLonelyDot) {continue;}
            
            //it hasnt
            //a new Grid0 is added with any other larger Grid(1-5)s if they are missing as well
            
        }
    }
    
    //Updates Grid's mass and the center of it
    
    
}





[numthreads(4, 4, 2)]
void AddorRemoveDots(int GroupIndex : SV_GroupIndex){
    if (changeDots[0].changeID == 69) { return; }
    
    

    int dotCount = miscData[0].dotCount;
    int freeSpace = miscData[0].freeSpace;
    int currFreeSpace = 0;

    int Start_cord = 0;
    int End_cord = 0;
    
    
    int B = floor((dotCount - 1.0) / ThreadSize);
    int E = (dotCount - 1.0) % ThreadSize;
    
    
    Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
    End_cord = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
    
    // add
    if (changeDots[0].changeID == 0 && GroupIndex == 0) 
    {   
        int iteration = 0;
        float dist = 1;
        
        for (int Current_Target_index = 0; Current_Target_index <= dotCount; Current_Target_index++)
        {
            if (inputData[Current_Target_index].mass == 0)
            {
                
                float current_theta = 0.0; //in radians
                float beta = 0.0;
                float n = 0;
                dist = 1;


                iteration++;
                InterlockedAdd(miscData[0].freeSpace, -1);
                
                inputData[Current_Target_index].mass = changeDots[0].changeDataMass;
                inputData[Current_Target_index].color = changeDots[0].changeDataCol;
                inputData[Current_Target_index].velocity = changeDots[0].changeDataVel;
                
                
                for (int id = 0; id < iteration; id++)
                {
                    beta = 2.0 * atan(0.5/dist);
                    n = (2.0 * PI)/beta;
                    
                    if ((id + floor(n)) < iteration){
                        id += floor(n);
                        dist++;
                    }
                    else if(floor(changeDots[0].radius) <= dist){
                        break;
                    }
                    else{
                        float alpha = (2.0*PI)/floor(n);
                        current_theta = abs(iteration-id)*alpha;
                        break;         
                    }
                    
                }

                inputData[Current_Target_index].position = float2(dist * cos(current_theta), dist * sin(current_theta)) + changeDots[0].centerPos;

                float2 newpos = inputData[Current_Target_index].position - changeDots[0].centerPos;

                float2x2 Forcematrix = {
                    cos(atan2(newpos.x, newpos.y)), -sin(atan2(newpos.x, newpos.y)),
                    sin(atan2(newpos.x, newpos.y)),  cos(atan2(newpos.x, newpos.y))
                };

                //inputData[Current_Target_index].velocity -= mul(float2(1, 1) * (G*G / dist), Forcematrix);// mul(float2(1, 1) * sqrt((G * changeDots[0].changeDataMass * newdotamount) / newpos), Forcematrix);
                

                

                
                if (floor(changeDots[0].radius) <= dist){
                    break;
                }
            }

        }
    }
    // remove
    else if (changeDots[0].changeID == 1) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius && inputData[Current_Target_index].mass != 0)
            {
                inputData[Current_Target_index].mass = 0;
                inputData[Current_Target_index].position = float2(0,0);
                inputData[Current_Target_index].velocity = float2(0,0);
                currFreeSpace++;
            }
        }
    }
    // change color
    else if (changeDots[0].changeID == 2) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius)
            {
                inputData[Current_Target_index].color = changeDots[0].changeDataCol;
            }
        }
    }
    // change mass
    else if (changeDots[0].changeID == 3) 
    {
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float2 poss = inputData[Current_Target_index].position;
            if (distance(changeDots[0].centerPos, poss) <= changeDots[0].radius)
            {
                inputData[Current_Target_index].mass = changeDots[0].changeDataMass;
            }
        }
    }

    
    InterlockedAdd(miscData[0].freeSpace, currFreeSpace);
}




//from inputdata, Grid0 to Grid2_TMP
[numthreads(64, 1, 1)]
void CopyBuffer(uint GroupIndex : SV_GroupIndex){

    uint numStructs = 0;
    uint stride = 0;

    switch (CopyID)
    {
       
       
        case 0:
            inputData.GetDimensions(numStructs, stride);
            for (uint pos = GroupIndex; pos < numStructs; pos += 64)
            {
                inputData[pos] = inputData_TMP[pos];
            }
            break;
        case 1:
            inputData_TMP.GetDimensions(numStructs, stride);
            for (uint pos1 = GroupIndex; pos1 < numStructs; pos1 += 64)
            {
                inputData_TMP[pos1] = inputData[pos1];
            }
            break;
    }
}


[numthreads(4, 4, 2)]
void CalcTrajectory(int GroupIndex : SV_GroupIndex)
{
    
    float2 currPoss = CenterBallPoss;
    float2 currVelo = changeDots[0].changeDataVel;
    uint dotCount = uint(miscData[0].dotCount);
    
    if (GroupIndex == 0) {trajPath[0].position = currPoss;}
    
    int B = floor((dotCount - 1.0) / ThreadSize);
    int E = (dotCount - 1.0) % ThreadSize;
    int Start_cord = (B + 1.0) * floor(min(E, (GroupIndex - 1.0)) + 1.0) + (B) * floor(max((GroupIndex - E - 1.0), 0.0));
    int End_cord = (B + 1.0) * floor(min(E, GroupIndex) + 1.0) + (B) * floor(max((GroupIndex - E), 0.0)) - 1.0;
    
    int index = 0;
    
    // calculates trajectories path
    for (int i = 1; i < Distance; i++)
    {
        calcForceTraj[GroupIndex] = 0;
    
        
        for (int Current_Target_index = Start_cord; Current_Target_index <= End_cord; Current_Target_index++)
        {
            float Current_Target_Mass = inputData[Current_Target_index].mass;
            // checks if object is not deleted
            if (Current_Target_Mass == 0) { continue; } 
            
            float2 Current_Target_Poss = inputData[Current_Target_index].position;
            
            // checks if its not too close
            if (distance(currPoss, Current_Target_Poss) <= 1) { continue; } 

            
            float F = G * ((Current_Target_Mass * changeDots[0].changeDataMass) / pow(distance(currPoss, Current_Target_Poss), 2.0)); // (pow(currPoss.x - Current_Target_Poss.x, 2) + pow(currPoss.y - Current_Target_Poss.y, 2))); 
            float alpha = atan2((currPoss.y - Current_Target_Poss.y), (currPoss.x - Current_Target_Poss.x));
            
            calcForceTraj[GroupIndex] += float2(cos(alpha) * F, sin(alpha) * F);
        }
    
        GroupMemoryBarrierWithGroupSync();

        // main thread (which is 0) sums all of the other threads results into one singular result
        if (GroupIndex == 0)
        {
        
            float2 summForce = float2(0,0);
            for (int i = 0; i < ThreadSize; i++)
            {
                summForce += calcForceTraj[i];
            }
        
            //Coneverts calculated force to bodies velocity
        
            //F=ma -> a=F/m

            //dont get why splitting vel calculations into 2 helps, but without it it causes extra unwanted vel
            currVelo += (summForce / changeDots[0].changeDataMass) * fixedDeltaTime * 0.5 * Resolution; //(1/Resolution)
        
            currPoss -= currVelo * fixedDeltaTime * Resolution;

            currVelo += (summForce / changeDots[0].changeDataMass) * fixedDeltaTime * 0.5 * Resolution;
            
            trajPath[index].position = currPoss;
            index++;
        }
    }
    trajPath[index].position = currPoss;
}